# -*- coding: utf-8 -*-
"""21201574_utsho_A3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M6BaXAKlaC3_cZq6rNf_V2I3TwYkspiY
"""

############################################################################  TASK-1  ################################################################


def calculate_utility(gene_sequence, target_sequence, weights):
    total_score = 0
    max_length = max(len(gene_sequence), len(target_sequence))

    for i in range(max_length):
        gene_char_ascii = ord(gene_sequence[i]) if i < len(gene_sequence) else 0
        target_char_ascii = ord(target_sequence[i]) if i < len(target_sequence) else 0
        weight = weights[i] if i < len(weights) else 1
        total_score += weight * abs(gene_char_ascii - target_char_ascii)
    return -total_score



def minimax_alpha_beta(pool, current_sequence, target_sequence, weights, is_maximizing, alpha, beta, depth_limit=None):

    if not pool or (depth_limit is not None and len(current_sequence) >= depth_limit):
        utility = calculate_utility(current_sequence, target_sequence, weights)
        return utility, current_sequence

    if is_maximizing:
        max_eval = float('-inf')
        best_sequence = current_sequence
        for nucleotide in pool:
            new_pool = pool.copy()
            new_pool.remove(nucleotide)
            eval_score, sequence = minimax_alpha_beta(
                new_pool,
                current_sequence + nucleotide,
                target_sequence,
                weights,
                False,
                alpha,
                beta,
                depth_limit
            )
            if eval_score > max_eval:
                max_eval = eval_score
                best_sequence = sequence
            alpha = max(alpha, eval_score)
            if beta <= alpha:
                break
        return max_eval, best_sequence
    else:
        min_eval = float('inf')
        best_sequence = current_sequence
        for nucleotide in pool:
            new_pool = pool.copy()
            new_pool.remove(nucleotide)
            eval_score, sequence = minimax_alpha_beta(
                new_pool,
                current_sequence + nucleotide,
                target_sequence,
                weights,
                True,
                alpha,
                beta,
                depth_limit
            )
            if eval_score < min_eval:
                min_eval = eval_score
                best_sequence = sequence
            beta = min(beta, eval_score)
            if beta <= alpha:
                break  # Alpha cut-off
        return min_eval, best_sequence


def solve_gene_sequence_problem(pool_str, target_sequence, student_id_str):
    pool = [nucleotide.strip() for nucleotide in pool_str.split(',')]
    student_id_digits = [int(x) for x in student_id_str.split()]
    n = len(target_sequence)

    weights = student_id_digits[-n:] if len(student_id_digits) >= n else student_id_digits
    while len(weights) < n:
        weights.extend(student_id_digits)
    weights = weights[:n]
    best_score, best_sequence = minimax_alpha_beta(
        pool,
        "",
        target_sequence,
        weights,
        True,
        float('-inf'),
        float('inf')
    )
    return best_sequence, best_score

# user input and output
def interactive_solve():
    print("Gene Sequence Generator using Minimax with Alpha-Beta Pruning")
    print("=" * 60)
    pool_input = input("Enter nucleotides pool (comma-separated): ").strip()
    target_input = input("Enter target gene sequence: ").strip()
    student_id_input = input("Enter student ID digits (space-separated): ").strip()
    best_sequence, utility_score = solve_gene_sequence_problem(pool_input, target_input, student_id_input)
    print("\nResult:")
    print(f"Best gene sequence generated: {best_sequence}")
    print(f"Utility score: {utility_score}")

if __name__ == "__main__":
    interactive_solve()

############################################################################  TASK-2  ################################################################


# ASCII value of a character,
def ascii_val(char):
    return ord(char) if char else 0


def compute_utility(gene, target, weights, booster_pos=None, booster_multiplier=1.0):
    utility = 0
    max_len = max(len(gene), len(target))
    for i in range(max_len):
        gene_char = gene[i] if i < len(gene) else None
        target_char = target[i] if i < len(target) else None
        weight = weights[i] if i < len(weights) else 1
        if booster_pos is not None and i >= booster_pos:
            weight *= booster_multiplier
        diff = abs(ascii_val(gene_char) - ascii_val(target_char))
        utility -= weight * diff
    return utility


def generate_permutations(pool, path, used, result, depth):
    if depth == len(pool):
        result.append(path[:])
        return
    for i in range(len(pool)):
        if not used[i]:
            used[i] = True
            path.append(pool[i])
            generate_permutations(pool, path, used, result, depth + 1)
            path.pop()
            used[i] = False


def simulate_game(pool, target, weights, sid_first2, include_special=False):
    booster_multiplier = int("".join(map(str, sid_first2))) / 100
    pool_copy = pool[:]
    if include_special:
        pool_copy.append('S')
    all_perms = []
    generate_permutations(pool_copy, [], [False]*len(pool_copy), all_perms, 0)
    best_sequence = None
    best_utility = float('-inf')
    for sequence in all_perms:
        sequence = sequence[:len(target)]
        gene = [''] * len(target)
        available = sequence.copy()
        for turn in range(len(target)):
            choices = []
            for c in available:
                gene[turn] = c
                util = compute_utility(gene, target, weights)
                choices.append((util, c))
            if turn % 2 == 0:
                chosen = max(choices)[1]
            else:
                chosen = min(choices)[1]
            gene[turn] = chosen
            available.remove(chosen)
        if include_special and 'S' in gene:
            s_pos = gene.index('S')
            utility = compute_utility(gene, target, weights, booster_pos=s_pos, booster_multiplier=booster_multiplier)
        else:
            utility = compute_utility(gene, target, weights)
        if utility > best_utility:
            best_utility = utility
            best_sequence = "".join(gene)
    return best_sequence, round(best_utility, 2)


def decide_better(pool_str, target_str, sid_digits):
    pool = pool_str.split(",")
    target = list(target_str)
    sid_last_n = sid_digits[-len(target):]
    sid_first2 = sid_digits[:2]
    _, score_without_special = simulate_game(pool, target, sid_last_n, sid_first2, include_special=False)
    seq_with_special, score_with_special = simulate_game(pool, target, sid_last_n, sid_first2, include_special=True)
    if score_with_special > score_without_special:
        print("YES")
    else:
        print("NO")
    print("With special nucleotide")
    print(f"Best gene sequence generated: {seq_with_special}, Utility score: {score_with_special}")


if __name__ == "__main__":
    pool_input = input("Enter nucleotides pool (comma-separated,): ").strip()
    target_input = input("Enter target gene sequence : ").strip()
    sid_input = list(map(int, input("Enter student ID digits (space-separated): ").strip().split()))
    decide_better(pool_input, target_input, sid_input)